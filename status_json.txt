"import { serve } from \"https://deno.land/std@0.224.0/http/server.ts\"\nimport { timingSafeEqual } from \"https://deno.land/std@0.224.0/crypto/timing_safe_equal.ts\"\nimport { createClient } from \"https://esm.sh/@supabase/supabase-js@2.45.1\"\nimport type { SupabaseClient } from \"https://esm.sh/@supabase/supabase-js@2.45.1\"\nimport { KOMMO_VEHICLE_FIELD_CODE, KOMMO_VEHICLE_FIELD_ID } from \"../_shared/kommo.ts\"\n\nconst SIGNATURE_HEADER = \"x-kommo-signature\"\nconst REQUIRE_SIGNATURE = false\nconst FEATURE_FLAG_KEY = \"enableKommoLive\"\nconst KOMMO_BASE_URL = Deno.env.get(\"KOMMO_BASE_URL\") ?? \"\"\nconst KOMMO_ACCESS_TOKEN = Deno.env.get(\"KOMMO_ACCESS_TOKEN\") ?? \"\"\nconst KOMMO_WEBHOOK_SECRET = Deno.env.get(\"KOMMO_WEBHOOK_SECRET\") ?? \"\"\nconst KOMMO_DELIVERY_FIELD_ID = Number(Deno.env.get(\"KOMMO_DELIVERY_FIELD_ID\") ?? \"1218176\")\nconst KOMMO_COLLECT_FIELD_ID = Number(Deno.env.get(\"KOMMO_COLLECT_FIELD_ID\") ?? \"1218178\")\n\nconst KOMMO_FIELD_IDS = {\n  deliveryLocation: 1218182,\n  collectLocation: 1234165,\n  deliveryFee: 1234177,\n  durationDays: 1234173,\n  priceDaily: 1232960,\n  insuranceFee: 1234175,\n  advancePayment: 1233272,\n  salesOrderUrl: 1224030,\n  agreementNumber: 806190,\n}\n\nconst DOCUMENT_FIELD_MAP = [\n  { fieldId: 1234167, docType: \"passport_id\" },\n  { fieldId: 1234169, docType: \"driver_license\" },\n  { fieldId: 1234171, docType: \"emirates_id\" },\n]\n\nconst DOCUMENTS_BUCKET = Deno.env.get(\"SUPABASE_STORAGE_DOCUMENTS_BUCKET\") ?? \"\"\n\nconst KOMMO_STATUS_CONFIG: Record<\n  string,\n  { label: string; bookingStatus: \"lead\" | \"confirmed\" | \"delivery\" | \"in_progress\" | \"completed\" | \"cancelled\" }\n> = {\n  \"75440391\": { label: \"Confirmed bookings\", bookingStatus: \"confirmed\" },\n  \"75440395\": { label: \"Delivery within 24 hours\", bookingStatus: \"delivery\" },\n  \"75440399\": { label: \"Car with customers\", bookingStatus: \"in_progress\" },\n}\n\nconst COUNTRY_MAP: Record<string, string> = {\n  uae: \"AE\",\n  \"united arab emirates\": \"AE\",\n  emirates: \"AE\",\n  dubai: \"AE\",\n  russia: \"RU\",\n  \"russian federation\": \"RU\",\n  russian: \"RU\",\n  ukraine: \"UA\",\n  kazakhstan: \"KZ\",\n  belarus: \"BY\",\n  india: \"IN\",\n  pakistan: \"PK\",\n  \"saudi arabia\": \"SA\",\n  ksa: \"SA\",\n  qatar: \"QA\",\n  kuwait: \"KW\",\n  oman: \"OM\",\n  bahrain: \"BH\",\n  usa: \"US\",\n  \"united states\": \"US\",\n  \"united states of america\": \"US\",\n}\n\nfunction requireEnv(name: string) {\n  const value = Deno.env.get(name)\n  if (!value) throw new Error(`Missing ${name} env var`)\n  return value\n}\n\nfunction getServiceClient() {\n  const supabaseUrl = requireEnv(\"SUPABASE_URL\")\n  const serviceRoleKey = requireEnv(\"SUPABASE_SERVICE_ROLE_KEY\")\n  return createClient(supabaseUrl, serviceRoleKey, {\n    auth: { persistSession: false },\n  })\n}\n\nasync function isFeatureFlagEnabled(client: SupabaseClient, flag: string) {\n  const { data } = await client\n    .from(\"system_feature_flags\")\n    .select(\"is_enabled\")\n    .eq(\"flag\", flag)\n    .maybeSingle()\n  return data?.is_enabled ?? false\n}\n\ntype SignatureValidation = {\n  ok: boolean\n  expected?: string\n  provided?: string | null\n  reason?: string\n}\n\nasync function validateSignature(rawBody: string, headerValue: string | null): Promise<SignatureValidation> {\n  if (!REQUIRE_SIGNATURE) return { ok: true }\n  if (!KOMMO_WEBHOOK_SECRET) return { ok: false, reason: \"missing_secret\", provided: headerValue }\n  if (!headerValue) return { ok: false, reason: \"missing_header\", provided: null }\n  const encoder = new TextEncoder()\n  const key = await crypto.subtle.importKey(\n    \"raw\",\n    encoder.encode(KOMMO_WEBHOOK_SECRET),\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\"]\n  )\n  const signature = await crypto.subtle.sign(\"HMAC\", key, encoder.encode(rawBody))\n  const expected = Array.from(new Uint8Array(signature))\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\")\n  const expectedBytes = encoder.encode(expected)\n  const providedBytes = encoder.encode(headerValue.toLowerCase())\n  if (expectedBytes.length !== providedBytes.length) {\n    return { ok: false, expected, provided: headerValue, reason: \"length_mismatch\" }\n  }\n  const valid = timingSafeEqual(expectedBytes, providedBytes)\n  return { ok: valid, expected, provided: headerValue, reason: valid ? undefined : \"mismatch\" }\n}\n\nasync function kommoGet(path: string) {\n  const url = `${KOMMO_BASE_URL}${path}`\n  const resp = await fetch(url, {\n    headers: {\n      Authorization: `Bearer ${KOMMO_ACCESS_TOKEN}`,\n      \"Content-Type\": \"application/json\",\n    },\n  })\n  if (!resp.ok) {\n    throw new Error(`Kommo request failed (${resp.status}): ${await resp.text()}`)\n  }\n  return resp.json()\n}\n\nfunction extractFieldValue(contact: any, code: string) {\n  if (!contact?.custom_fields_values) return null\n  const field = contact.custom_fields_values.find((f: any) => (f.code ?? f.field_code) === code)\n  return field?.values?.[0]?.value ?? null\n}\n\nfunction extractFieldByName(contact: any, name: string) {\n  if (!contact?.custom_fields_values) return null\n  const target = name.toLowerCase()\n  const field = contact.custom_fields_values.find((f: any) => {\n    const label = (f.name ?? f.field_name ?? f.code ?? \"\").toLowerCase()\n    return label === target\n  })\n  return field?.values?.[0]?.value ?? null\n}\n\nfunction normalizeCountryLabel(value: string | null) {\n  if (!value) return null\n  const trimmed = value.trim()\n  if (!trimmed) return null\n  if (/^[A-Za-z]{2}$/.test(trimmed)) {\n    return trimmed.toUpperCase()\n  }\n  const lower = trimmed.toLowerCase()\n  if (COUNTRY_MAP[lower]) {\n    return COUNTRY_MAP[lower]\n  }\n  return trimmed\n}\n\nfunction normalizeGenderLabel(value: string | null) {\n  if (!value) return null\n  const trimmed = value.trim()\n  if (!trimmed) return null\n  const lower = trimmed.toLowerCase()\n  if ([\"male\", \"m\", \"man\"].includes(lower)) return \"Male\"\n  if ([\"female\", \"f\", \"woman\"].includes(lower)) return \"Female\"\n  return trimmed.charAt(0).toUpperCase() + trimmed.slice(1)\n}\n\nfunction getCustomFields(entity: any) {\n  return Array.isArray(entity?.custom_fields_values) ? entity.custom_fields_values : []\n}\n\nfunction findCustomField(entity: any, fieldId: number) {\n  return getCustomFields(entity).find((field: any) => Number(field?.field_id ?? 0) === fieldId)\n}\n\nfunction extractStringField(entity: any, fieldId: number) {\n  const field = findCustomField(entity, fieldId)\n  if (!field || !Array.isArray(field.values) || !field.values.length) return null\n  const entry = field.values[0]\n  if (entry?.value === null || entry?.value === undefined) {\n    if (entry?.enum_code) return String(entry.enum_code)\n    if (entry?.enum_id !== undefined) return String(entry.enum_id)\n    return null\n  }\n  if (typeof entry.value === \"object\") {\n    return null\n  }\n  return String(entry.value)\n}\n\nfunction extractNumericField(entity: any, fieldId: number) {\n  const raw = extractStringField(entity, fieldId)\n  if (!raw) return null\n  const numeric = Number(raw)\n  return Number.isFinite(numeric) ? numeric : null\n}\n\nfunction extractIntegerField(entity: any, fieldId: number) {\n  const raw = extractStringField(entity, fieldId)\n  if (!raw) return null\n  const parsed = parseInt(raw, 10)\n  return Number.isFinite(parsed) ? parsed : null\n}\n\nfunction mapBookingStatus(statusId: string) {\n  return KOMMO_STATUS_CONFIG[statusId]?.bookingStatus ?? \"lead\"\n}\n\nfunction mapPipelineStage(pipelineId: string, statusId: string) {\n  const map: Record<string, Record<string, string>> = {\n    \"9815931\": {\n      \"75440391\": \"skyluxse_confirmed\",\n      \"79790631\": \"skyluxse_bot_answering\",\n      \"75440395\": \"skyluxse_delivery_24h\",\n      \"75440399\": \"skyluxse_with_customer\",\n    },\n  }\n  return map[pipelineId]?.[statusId] ?? null\n}\n\nfunction leadSourcePayloadId(leadId: number | string) {\n  return `kommo:${leadId}`\n}\n\nasync function upsertClient(client: SupabaseClient, contact: any, fallbackName: string) {\n  const kommoContactId = contact?.id ? String(contact.id) : null\n  const phone = extractFieldValue(contact, \"PHONE\")\n  const email = extractFieldValue(contact, \"EMAIL\")\n  const nationality = normalizeCountryLabel(extractFieldByName(contact, \"Nationality\"))\n  const gender = normalizeGenderLabel(extractFieldByName(contact, \"Gender\"))\n\n  const payload: Record<string, any> = {\n    kommo_contact_id: kommoContactId,\n    name: contact?.name ?? fallbackName ?? \"Komмо contact\",\n  }\n\n  if (phone) payload.phone = phone\n  if (email) payload.email = email\n  if (nationality) payload.residency_country = nationality\n  if (gender) payload.gender = gender\n\n  const { data, error } = await client\n    .from(\"clients\")\n    .upsert(payload, { onConflict: \"kommo_contact_id\" })\n    .select(\"id\")\n    .maybeSingle()\n\n  if (error) throw error\n  return data?.id ?? null\n}\n\nasync function upsertSalesLead(\n  client: SupabaseClient,\n  lead: any,\n  clientId: string | null,\n  stageId: string | null\n) {\n  const leadCode = leadSourcePayloadId(lead.id)\n  const payload: Record<string, any> = {\n    lead_code: leadCode,\n    client_id: clientId,\n    value_amount: lead.price ?? 0,\n    updated_at: new Date().toISOString(),\n  }\n  if (stageId) payload.stage_id = stageId\n\n  const { data, error } = await client\n    .from(\"sales_leads\")\n    .upsert(payload, { onConflict: \"lead_code\" })\n    .select(\"id\")\n    .maybeSingle()\n\n  if (error) throw error\n  return data?.id ?? null\n}\n\ntype BookingOptions = {\n  vehicleId?: string | null\n  startAt?: string | null\n  endAt?: string | null\n}\n\nasync function upsertBooking(\n  client: SupabaseClient,\n  lead: any,\n  clientId: string | null,\n  bookingStatus: string,\n  options: BookingOptions = {}\n) {\n  const sourcePayloadId = leadSourcePayloadId(lead.id)\n  const { data: existing, error: fetchError } = await client\n    .from(\"bookings\")\n    .select(\"id\")\n    .eq(\"source_payload_id\", sourcePayloadId)\n    .maybeSingle()\n\n  if (fetchError) throw fetchError\n\n  const payload: Record<string, any> = {\n    channel: \"Kommo\",\n    source_payload_id: sourcePayloadId,\n    client_id: clientId,\n    status: bookingStatus,\n    total_amount: lead?.price ?? 0,\n    external_code: `K-${lead.id}`,\n    kommo_status_id: lead?.status_id ? Number(lead.status_id) : null,\n  }\n\n  if (options.vehicleId !== undefined) payload.vehicle_id = options.vehicleId\n  if (options.startAt !== undefined) payload.start_at = options.startAt\n  if (options.endAt !== undefined) payload.end_at = options.endAt ?? options.startAt ?? null\n  if (options.deliveryFeeLabel !== undefined) payload.delivery_fee_label = options.deliveryFeeLabel\n  if (options.deliveryLocation !== undefined) payload.delivery_location = options.deliveryLocation\n  if (options.collectLocation !== undefined) payload.collect_location = options.collectLocation\n  if (options.rentalDurationDays !== undefined) payload.rental_duration_days = options.rentalDurationDays\n  if (options.priceDaily !== undefined) payload.price_daily = options.priceDaily\n  if (options.insuranceFeeLabel !== undefined) payload.insurance_fee_label = options.insuranceFeeLabel\n  if (options.advancePayment !== undefined) payload.advance_payment = options.advancePayment\n  if (options.salesOrderUrl !== undefined) payload.sales_order_url = options.salesOrderUrl\n  if (options.agreementNumber !== undefined) payload.agreement_number = options.agreementNumber\n\n  if (existing) {\n    const { error } = await client\n      .from(\"bookings\")\n      .update(payload)\n      .eq(\"id\", existing.id)\n    if (error) throw error\n    return existing.id\n  } else {\n    const insertPayload = {\n      ...payload,\n      booking_type: \"rental\",\n      priority: \"medium\",\n    }\n    const { data, error } = await client\n      .from(\"bookings\")\n      .insert(insertPayload)\n      .select(\"id\")\n      .single()\n    if (error) throw error\n    return data.id\n  }\n}\n\nasync function logBookingTimelineEvent(\n  client: SupabaseClient,\n  bookingId: string,\n  statusId: string,\n  label: string,\n  pipelineId: string | number\n) {\n  const { error } = await client.from(\"booking_timeline_events\").insert({\n    booking_id: bookingId,\n    event_type: \"kommo_status_sync\",\n    message: `Kommo stage updated: ${label}`,\n    payload: {\n      status_id: statusId,\n      stage_label: label,\n      pipeline_id: pipelineId,\n    },\n  })\n  if (error) throw error\n}\n\ntype HandleResult = {\n  leadId: number | string\n  processed?: boolean\n  skipped?: boolean\n  statusId: string | null\n  statusLabel: string | null\n}\n\nfunction asString(value: unknown): string | null {\n  if (value == null) return null\n  if (typeof value === \"string\") {\n    const trimmed = value.trim()\n    return trimmed.length ? trimmed : null\n  }\n  if (typeof value === \"number\" && Number.isFinite(value)) {\n    return value.toString()\n  }\n  return null\n}\n\nfunction extractKommoVehicleId(entity: any): string | null {\n  const direct =\n    asString(entity?.vehicle_id) ||\n    asString(entity?.vehicleId) ||\n    asString(entity?.vehicle?.id)\n  if (direct) return direct\n\n  const fields = Array.isArray(entity?.custom_fields_values) ? entity.custom_fields_values : []\n  for (const field of fields) {\n    if (!field || typeof field !== \"object\") continue\n    const fieldIdMatches = KOMMO_VEHICLE_FIELD_ID\n      ? String(field?.field_id ?? \"\") === KOMMO_VEHICLE_FIELD_ID\n      : false\n    const fieldCodeMatches = KOMMO_VEHICLE_FIELD_CODE\n      ? String(field?.field_code ?? field?.code ?? \"\").toLowerCase() === KOMMO_VEHICLE_FIELD_CODE\n      : false\n    if (!fieldIdMatches && !fieldCodeMatches) continue\n    const values = Array.isArray(field?.values) ? field.values : []\n    for (const entry of values) {\n      const candidate = asString(entry?.value ?? entry?.enum_code ?? entry?.enum)\n      if (candidate) return candidate\n    }\n  }\n  return null\n}\n\nasync function findVehicleByKommoId(client: SupabaseClient, kommoVehicleId: string) {\n  const { data, error } = await client\n    .from(\"vehicles\")\n    .select(\"id, kommo_vehicle_id\")\n    .eq(\"kommo_vehicle_id\", kommoVehicleId)\n    .maybeSingle()\n  if (error) {\n    console.error(\"Failed to lookup vehicle by Kommo ID\", { kommoVehicleId, error })\n    return null\n  }\n  return data\n}\n\nfunction extractKommoEpoch(lead: any, fieldId: number): string | null {\n  if (!fieldId) return null\n  const fields = Array.isArray(lead?.custom_fields_values) ? lead.custom_fields_values : []\n  for (const field of fields) {\n    if (Number(field?.field_id ?? 0) !== fieldId) continue\n    const values = Array.isArray(field?.values) ? field.values : []\n    for (const entry of values) {\n      const raw = asString(entry?.value ?? entry?.enum_code ?? entry?.enum)\n      if (!raw) continue\n      const numeric = Number(raw)\n      if (Number.isFinite(numeric)) {\n        return new Date(numeric * 1000).toISOString()\n      }\n      const parsed = Date.parse(raw)\n      if (!Number.isNaN(parsed)) {\n        return new Date(parsed).toISOString()\n      }\n    }\n  }\n  return null\n}\n\nfunction formatError(error: unknown) {\n  if (error instanceof Error) return error.message\n  try {\n    return JSON.stringify(error)\n  } catch {\n    return String(error)\n  }\n}\n\ntype PathToken = string | number\n\ntype BookingOptions = {\n  vehicleId?: string | null\n  startAt?: string | null\n  endAt?: string | null\n  deliveryFeeLabel?: string | null\n  deliveryLocation?: string | null\n  collectLocation?: string | null\n  rentalDurationDays?: number | null\n  priceDaily?: number | null\n  insuranceFeeLabel?: string | null\n  advancePayment?: number | null\n  salesOrderUrl?: string | null\n  agreementNumber?: string | null\n}\n\nfunction parseFormEncodedPayload(rawBody: string) {\n  const params = new URLSearchParams(rawBody)\n  const result: Record<string, any> = {}\n\n  const tokenize = (key: string): PathToken[] => {\n    const tokens: PathToken[] = []\n    key.replace(/([^\\[\\]]+)|\\[(.*?)\\]/g, (_, head, bracket) => {\n      const token = head ?? bracket ?? \"\"\n      if (token === \"\") return \"\"\n      const numeric = Number(token)\n      tokens.push(Number.isInteger(numeric) && String(numeric) === token ? numeric : token)\n      return \"\"\n    })\n    return tokens\n  }\n\n  const assignValue = (target: any, tokens: PathToken[], value: string) => {\n    let current = target\n    tokens.forEach((token, index) => {\n      const isLast = index === tokens.length - 1\n      const nextToken = tokens[index + 1]\n\n      if (isLast) {\n        if (typeof token === \"number\") {\n          if (!Array.isArray(current)) {\n            throw new Error(\"Unexpected array index for non-array container\")\n          }\n          current[token] = value\n        } else {\n          current[token] = value\n        }\n        return\n      }\n\n      if (typeof token === \"number\") {\n        if (!Array.isArray(current)) {\n          throw new Error(\"Unexpected array index for non-array container\")\n        }\n        if (current[token] === undefined) current[token] = typeof nextToken === \"number\" ? [] : {}\n        current = current[token]\n      } else {\n        if (current[token] === undefined) current[token] = typeof nextToken === \"number\" ? [] : {}\n        current = current[token]\n      }\n    })\n  }\n\n  for (const [key, value] of params.entries()) {\n    const tokens = tokenize(key)\n    if (!tokens.length) continue\n    assignValue(result, tokens, value)\n  }\n\n  return result\n}\n\nasync function handleStatusChange(client: SupabaseClient, event: any): Promise<HandleResult> {\n  const statusId = String(event.status_id ?? \"\")\n  const config = KOMMO_STATUS_CONFIG[statusId]\n  if (!config) {\n    return { leadId: event.id, skipped: true, statusId, statusLabel: null }\n  }\n\n  const lead = await kommoGet(`/api/v4/leads/${event.id}?with=contacts,custom_fields`)\n  const contactId = lead?._embedded?.contacts?.find((c: any) => c.is_main)?.id ?? lead?._embedded?.contacts?.[0]?.id\n  const contact = contactId ? await kommoGet(`/api/v4/contacts/${contactId}?with=custom_fields`) : null\n\n  const clientId = await upsertClient(client, contact, lead.name ?? `Lead ${event.id}`)\n  if (clientId) {\n    await syncClientDocuments(client, contact, clientId).catch((error) =>\n      console.error(\"Failed to sync Kommo documents\", error)\n    )\n  }\n  const stageId = mapPipelineStage(String(event.pipeline_id), String(event.status_id))\n  await upsertSalesLead(client, lead, clientId, stageId)\n  const bookingStatus = mapBookingStatus(statusId)\n  const kommoVehicleId = extractKommoVehicleId(lead)\n  let vehicleMatch: { id: string } | null = null\n  if (kommoVehicleId) {\n    vehicleMatch = await findVehicleByKommoId(client, kommoVehicleId)\n    if (!vehicleMatch) {\n      console.warn(\"Vehicle from Kommo not found in Supabase\", { kommoVehicleId })\n    }\n  }\n\n  const startAt =\n    extractKommoEpoch(lead, KOMMO_DELIVERY_FIELD_ID) ?? extractKommoEpoch(lead, KOMMO_COLLECT_FIELD_ID)\n  const endAt = extractKommoEpoch(lead, KOMMO_COLLECT_FIELD_ID) ?? startAt ?? null\n\n  const bookingId = await upsertBooking(\n    client,\n    lead,\n    clientId,\n    bookingStatus,\n    buildBookingOptions(lead, {\n      vehicleId: vehicleMatch?.id ?? null,\n      startAt: startAt ?? null,\n      endAt: endAt ?? null,\n    })\n  )\n  if (bookingId) {\n    await logBookingTimelineEvent(client, bookingId, statusId, config.label, event.pipeline_id)\n  }\n\n  return { leadId: event.id, processed: true, statusId, statusLabel: config.label }\n}\n\nfunction buildBookingOptions(\n  lead: any,\n  base: { vehicleId?: string | null; startAt?: string | null; endAt?: string | null }\n): BookingOptions {\n  return {\n    vehicleId: base.vehicleId ?? null,\n    startAt: base.startAt ?? null,\n    endAt: base.endAt ?? null,\n    deliveryFeeLabel: extractStringField(lead, KOMMO_FIELD_IDS.deliveryFee),\n    deliveryLocation: extractStringField(lead, KOMMO_FIELD_IDS.deliveryLocation),\n    collectLocation: extractStringField(lead, KOMMO_FIELD_IDS.collectLocation),\n    rentalDurationDays: extractIntegerField(lead, KOMMO_FIELD_IDS.durationDays),\n    priceDaily: extractNumericField(lead, KOMMO_FIELD_IDS.priceDaily),\n    insuranceFeeLabel: extractStringField(lead, KOMMO_FIELD_IDS.insuranceFee),\n    advancePayment: extractNumericField(lead, KOMMO_FIELD_IDS.advancePayment),\n    salesOrderUrl: extractStringField(lead, KOMMO_FIELD_IDS.salesOrderUrl),\n    agreementNumber: extractStringField(lead, KOMMO_FIELD_IDS.agreementNumber),\n  }\n}\n\nasync function syncClientDocuments(client: SupabaseClient, contact: any, clientId: string | null) {\n  if (!clientId || !contact?.id) return\n  if (!DOCUMENTS_BUCKET) {\n    console.warn(\"SUPABASE_STORAGE_DOCUMENTS_BUCKET not set, skipping Kommo document sync\")\n    return\n  }\n\n  for (const mapping of DOCUMENT_FIELD_MAP) {\n    const field = findCustomField(contact, mapping.fieldId)\n    if (!field || !Array.isArray(field.values)) continue\n    for (const entry of field.values) {\n      const fileMeta = entry?.value\n      const fileUuid = fileMeta?.file_uuid\n      if (!fileUuid) continue\n      await ensureClientDocument(client, {\n        fileUuid: String(fileUuid),\n        fileName: fileMeta?.file_name ?? `${fileUuid}.bin`,\n        fileSize: fileMeta?.file_size ?? null,\n        versionUuid: fileMeta?.version_uuid ?? null,\n        docType: mapping.docType,\n        clientId,\n        contactId: String(contact.id),\n        fieldId: mapping.fieldId,\n      })\n    }\n  }\n}\n\ntype DocumentSyncPayload = {\n  fileUuid: string\n  fileName: string\n  fileSize: number | null\n  versionUuid: string | null\n  docType: string\n  clientId: string\n  contactId: string\n  fieldId: number\n}\n\nasync function ensureClientDocument(client: SupabaseClient, payload: DocumentSyncPayload) {\n  const { data: existingDoc, error: lookupError } = await client\n    .from(\"documents\")\n    .select(\"id\")\n    .eq(\"metadata->>kommo_file_uuid\", payload.fileUuid)\n    .maybeSingle()\n\n  if (lookupError) {\n    console.error(\"Failed to lookup existing documents\", lookupError)\n    return\n  }\n\n  let documentId = existingDoc?.id ?? null\n\n  if (!documentId) {\n    const fileInfo = await kommoGet(`/api/v4/files/${payload.fileUuid}`).catch((error) => {\n      console.error(\"Failed to fetch Kommo file metadata\", { fileUuid: payload.fileUuid, error })\n      return null\n    })\n    if (!fileInfo) return\n\n    const downloadLink = fileInfo?.download_link ?? fileInfo?.file?.download_link\n    if (!downloadLink) {\n      console.error(\"Kommo file metadata missing download link\", { fileUuid: payload.fileUuid })\n      return\n    }\n\n    const fileResponse = await fetch(downloadLink)\n    if (!fileResponse.ok) {\n      console.error(\"Failed to download Kommo file\", { fileUuid: payload.fileUuid, status: fileResponse.status })\n      return\n    }\n    const arrayBuffer = await fileResponse.arrayBuffer()\n    const mimeType = fileResponse.headers.get(\"content-type\") ?? \"application/octet-stream\"\n    const blob = new Blob([arrayBuffer], { type: mimeType })\n    const storagePath = `clients/${payload.clientId}/${payload.docType}/${payload.fileUuid}-${payload.fileName}`\n\n    const { error: uploadError } = await client.storage\n      .from(DOCUMENTS_BUCKET)\n      .upload(storagePath, blob, { contentType: mimeType, upsert: true })\n    if (uploadError) {\n      console.error(\"Failed to upload document to Supabase storage\", uploadError)\n      return\n    }\n\n    const { data: insertedDoc, error: insertDocError } = await client\n      .from(\"documents\")\n      .insert({\n        storage_path: storagePath,\n        original_name: payload.fileName,\n        mime_type: mimeType,\n        size_bytes: payload.fileSize ?? arrayBuffer.byteLength,\n        source: \"Kommo\",\n        status: \"needs_review\",\n        metadata: {\n          kommo_file_uuid: payload.fileUuid,\n          kommo_field_id: payload.fieldId,\n          kommo_contact_id: payload.contactId,\n          kommo_version_uuid: payload.versionUuid,\n        },\n      })\n      .select(\"id\")\n      .single()\n\n    if (insertDocError || !insertedDoc) {\n      console.error(\"Failed to insert document row\", insertDocError)\n      return\n    }\n    documentId = insertedDoc.id\n  }\n\n  if (!documentId) return\n\n  const { data: existingLink } = await client\n    .from(\"document_links\")\n    .select(\"id\")\n    .eq(\"document_id\", documentId)\n    .eq(\"entity_id\", payload.clientId)\n    .eq(\"doc_type\", payload.docType)\n    .limit(1)\n    .maybeSingle()\n\n  if (!existingLink) {\n    const { error: linkError } = await client.from(\"document_links\").insert({\n      document_id: documentId,\n      scope: \"client\",\n      entity_id: payload.clientId,\n      doc_type: payload.docType,\n    })\n    if (linkError) {\n      console.error(\"Failed to create document link\", linkError)\n    }\n  }\n}\n\nserve(async (req) => {\n  try {\n    if (req.method !== \"POST\") {\n      return new Response(JSON.stringify({ error: \"Method not allowed\" }), { status: 405 })\n    }\n\n    const rawBody = await req.text()\n    const signature = req.headers.get(SIGNATURE_HEADER)\n    const validation = await validateSignature(rawBody, signature)\n    if (!validation.ok) {\n      console.error(\"Invalid Kommo signature\", {\n        reason: validation.reason,\n        provided: validation.provided,\n        expectedPrefix: validation.expected?.slice(0, 12),\n      })\n      return new Response(JSON.stringify({ error: \"Invalid signature\" }), { status: 401 })\n    }\n\n    let payload: any\n    let parsed = false\n    try {\n      payload = JSON.parse(rawBody)\n      parsed = true\n    } catch (jsonError) {\n      try {\n        payload = parseFormEncodedPayload(rawBody)\n        parsed = true\n      } catch (formError) {\n        console.error(\"Invalid Kommo payload\", {\n          jsonError: formatError(jsonError),\n          formError: formatError(formError),\n        })\n        return new Response(JSON.stringify({ error: \"Invalid JSON payload\" }), { status: 400 })\n      }\n    }\n\n    if (!parsed) {\n      console.error(\"Unable to parse Kommo payload\", rawBody.slice(0, 120))\n      return new Response(JSON.stringify({ error: \"Invalid payload\" }), { status: 400 })\n    }\n\n    const supabase = getServiceClient()\n\n    const live = await isFeatureFlagEnabled(supabase, FEATURE_FLAG_KEY)\n    if (!live) {\n      return new Response(JSON.stringify({ error: \"Kommo integration disabled\" }), { status: 403 })\n    }\n\n    const statusEventsRaw = payload?.leads?.status\n    const statusEvents = Array.isArray(statusEventsRaw) ? statusEventsRaw : []\n    if (!Array.isArray(statusEventsRaw)) {\n      console.warn(\"Kommo status payload without iterable status array\", {\n        hasLeads: Boolean(payload?.leads),\n      })\n    }\n\n    const results = []\n    for (const event of statusEvents) {\n      try {\n        const result = await handleStatusChange(supabase, event)\n        await supabase.from(\"kommo_webhook_events\").insert({\n          source_payload_id: String(event.id),\n          payload,\n          hmac_validated: true,\n          status: result?.skipped ? \"skipped\" : \"processed\",\n          kommo_status_id: result?.statusId ?? String(event.status_id ?? \"\"),\n          kommo_status_label: result?.statusLabel ?? null,\n        })\n        results.push(result)\n      } catch (error) {\n        const errorMessage = formatError(error)\n        console.error(\"Failed to process status event\", errorMessage, error)\n        await supabase.from(\"kommo_webhook_events\").insert({\n          source_payload_id: String(event.id),\n          payload,\n          hmac_validated: true,\n          status: \"failed\",\n          kommo_status_id: String(event.status_id ?? \"\"),\n          kommo_status_label: KOMMO_STATUS_CONFIG[String(event.status_id ?? \"\")]?.label ?? null,\n          error_message: errorMessage\n        })\n        results.push({ leadId: event.id, error: errorMessage })\n      }\n    }\n\n    return new Response(JSON.stringify({ processed: results }), { status: 200 })\n  } catch (error) {\n    const message = formatError(error)\n    console.error(\"kommo-status-webhook fatal error\", message, error)\n    return new Response(JSON.stringify({ error: \"Internal server error\", details: message }), {\n      status: 500,\n    })\n  }\n})\n"
